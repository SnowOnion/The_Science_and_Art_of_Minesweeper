[pic1.1]: 1.1.bmp "要来一发吗？"
[pic1.2]: 1.2.bmp "一库！"
[pic2.1]: 2.1.bmp "..."
[pic2.2]: 2.2.bmp "..."
[pic2.3]: 2.3.bmp "..."
[pic2.4]: 2.4.bmp "..."
[pic4.1]: 4.1.bmp "..."
[pic4.2]: 4.2.bmp "..."
[pic4.3]: 4.3.bmp "..."
[pic4.4]: 4.4.bmp "..."

#扫雷的科学与艺术

##0. 这是什么

关于解扫雷算法的理论研究。它曾经是一个给学院的杂志投稿的版本，正在成为一个充当概率论课论文的版本 ~~，即将成为发SCI的版本~~ 。
大体上说，本文目前还是扯淡为主，暂时不能对 *自动化扫雷求解器* 的实现提供太多帮助。
而且很可能永远不会对 *提高手工解扫雷的成绩* 提供帮助。

##1. 规则简介
扫雷游戏的 __局面__ 是一个由 **方块** 构成的矩阵，每个方块下面可能藏着雷，也可能没有雷。如果打开一个 **雷块** ，则游戏失败；如果打开一个 **非雷方块** ，则在该块上会显示一个数字，代表其周围8格内的雷的数量。游戏的目标是，打开所有非雷方块。
大多数扫雷游戏（如Windows各版本自带的扫雷，或专业的MineSweeper Clone）的操作方式是：
左键点击未打开的方块，则 **打开** 它（若数字为0，则再打开它周围的8格）；右键点击未打开的方块，则在此做一 **标记** ，表示玩家认为此处是雷；左键双击(Double clicking)或左右键同时点击( **Chording**  )已打开的方块，若方块周围8格内的标记数等于方块上的数字，则自动打开周围8格内未打开的方块。
另外，扫雷游戏往往会提示剩余雷数，即总雷数减去已做标记数。

图1.1是一个游戏局面，画◆的方块是被标记的，深色方块实际上是被打开且数字为0的，无色方块是未被打开的。图1.2是一个胜利局面，可以看出并非所有雷都需要被标记。两图下方数字是剩余雷数。

![alt text of pic1.1][pic1.1]
![][pic1.2]


##2. 基本的手解扫雷技巧
本文的核心是讨论解扫雷算法：输入一个游戏局面（包括剩余雷数这个信息），算法输出“玩家下一步要干什么”。解扫雷算法的一个研究思路是模拟人扫雷的过程。所以我们来看一下基本的扫雷技巧。
为了简便，定义以下操作：
+打开a格，称为 **open a** ；
+在a格做标记，称为 **flag a** ；
+打开a格周围8格内所有未标记的格，称为 **chord a** .

例2.1 见图2.1，其中字母a~g仅用来方便区分格子。

![][pic2.1]

一个非常自然的操作序列是：看见f周围只有a没打开，于是flag a；发现e和g的数字被满足，于是chord e，chord g。

例2.2 见图2.2。

![][pic2.2]

考虑g，它使abc中有且只有一个雷；考虑f，它使得ab中有且只有一个雷，于是abc中的那个雷一定在ab里；所以c不是雷，open c。

例2.3 见图23。

![][pic2.3]

考虑h，它使bcd中有且只有两个雷；考虑g，它使得abc中有且只有一个雷，于是bcd中的两个雷不能聚集在bc，于是d是雷，flag d；局面化为2.2的情形，open a。

例2.4 见图2.4。

![][pic2.4]

考虑b，它使efghj中有且只有三个雷；考虑a，它使得def中有且只有一个雷，于是efghj的三个雷中有至少有两个雷在ghj；（某种程度上，现在已经化为2.3的情形）考虑c，它使得hj中有且只有一个雷，于是ghj的至少两个雷中又至少有一个雷在g，flag g。

##3. 确定型解扫雷算法

###丰满（？）的理论

我们的目的是搞出解扫雷算法，那么就需要把上面所示的这些经验形式化，从而编写相应程序。
下面还是定义一些术语和符号：
+ 称未打开且未标记的格子为 **闲者** ；
+ 称由闲者构成的集合为 **闲者集** ；
+ 对于打开的格子a，称其周围8格中的闲者的集合为 **a的1阶闲者集** ，记为a的大写A。
+ 记闲者集A包含的格数为 **|A|** ，包含的雷数为 **(A)** 。显然，0<=(A)<=|A|。
+ 两个闲者集A，B可以进行集合的并、交、差操作，分别记为 **A∪B** ， **AB** ， **A\B** ；显然，操作的结果仍然是闲者集。我们称由k阶闲者集和1阶闲者集并、交、差而成的闲者集为 **k+1阶闲者集** 。
+ 打开闲者集A所有格子的操作，记为 **open A** ；标记闲者集A所有格子的操作，记为 **flag A** 。

回顾例2.1，我们实际上先考虑了f的闲者集F，发现(F)=|F|，于是果断地flag F；这导致(E)=0，(G)=0，于是我们果断地open E，open G（或者说，chrod e，chrod g）。
于是可以总结出算法：

** 1. 当(A)=0，则open A；
2. 当(A)=|A|，则flag A。**

这种算法只考虑了1个闲者集，且称它为MD(1)分析法。MD的含义是MineSweeper DeterminedSolving，即这种分析是确定型的，以区别于下述的概率型算法。

再看例2.2和例2.3，我们实际上考虑了2个闲者集。将它形式化，可以得到MD(2)分析法。简略的推导过程如下：

+ (B\A)=(B)-(AB)>=(B)-(A)，若(B)-(A)>=|B\A|，则(B\A)>=|B\A|，则(B\A)=|B\A|，则应flag B\A。
+ (B\A)=(B)-(AB)<=(B)-[(A)-(A\B)]<=(B)-(A)+|A\B|，若(B)-(A)+|A\B|<=0，则(B\A)<=0，则(B\A)=0，则应open B\A。
+ 对(A\B)做类似对称的推导，也可以得到类似的两个规则。

最终，MD(2)分析法表述如下：

** 1. 当(A)-(B)>=|A\B|，则flag A\B，open B\A；
2. 当(B)-(A)>=|B\A|，则flag B\A，open A\B。**

最后是丧心病狂的例2.4，我们实际上考虑了3个闲者集……也许我们该发展MD(3)分析法乃至MD(k)分析法。但是呢，根据实战经验，当MD(2)分析法束手无策时，MD(3)分析法能发挥作用的时候并不多。一个实用的情形是：三个闲者集ABC，B分别与A、C相交，但A和C不相交。例2.4就是这种情形。

推导一下：
(B\[A∪C])=(B)-(AB)-(AC)>=(B)-(A)-(C)，若(B)-(A)-(C)>=|B\[A∪C]|，则(B\[A∪C])>=|B\[A∪C]|，则(B\[A∪C])=|B\[A∪C]|，则应flag B\[A∪C]。

我们姑且称之为NMD(3)分析法，N表示Naive。表述如下：

**1. 当(B)-(A)-(C)>=|B\[A∪C]|，则flag B\[A∪C]。**

以上就是有实用性的确定型扫雷算法MD(1)，MD(2)和NMD(3)。基本上，就是我们手解扫雷的形式化表述。

###骨感的实现

那么，如何编程实现这几个分析法呢？

有n个“裸露”的打开了的方格，就有n个1阶闲者集。容易获得任意1阶闲者集A的(A)，也容易获得任意闲者集B的|B|。但是，要按什么顺序去考虑这些闲者们？

我个人的思路如下：每个1阶闲者集作为无向图的一个结点，有交集的1阶闲者集之间有一条边相连。于是一个游戏局面就对应了一个图（可能由很多连通子图组成）。然后去按某种顺序遍历这个图：先对每个结点使用MD(1)分析；分析过程中有open操作，会产生新的信息，把所有因此受影响的闲者集加入/移出图，或标记为“需要再次访问”；当对每一结点MD(1)分析都无能为力，则采用MD(2)分析，对每两个相邻的结点再次遍历……再采用NMD(3)分析遍历……

在MD(2)分析遍历时，可以想见，经常会出现可以用MD(1)分析解决的游戏局部，这时就应适当回退到MD(1)分析。为了告诉程序回退的时机，就应该在每个结点记录更多的分析信息。这方面的优化有待于进一步研究。

但是呢，即使用最暴力的搜索方式，运用这几种分析法也是可以解决大部分局面的，除非遇到下文所谓“概率瓶颈”。所以，确定型分析法先告一段落，我们看一下概率型分析法。

##4. 概率型解扫雷算法

例4.1 例4.2 如图4.1和图4.2所示：

![][pic4.1]
![][pic4.2]

好吧，在4.1，你必须2中蒙1；在4.2，你必须在左上-右下，和右上-左下的雷阵中痛苦抉择。发生这种事情，大家都不愿意的。诶，你想不想过关啊？我打开下面给你看，“BOOM——”……
扫雷呢，最重要的是开心，这种局面就很不开心。可以称之为“概率瓶颈”，或者更带感一些，“理性地狱”。我们的概率型算法也并不处理这种情形。
要描述概率型算法，先看一看概率的正确计算方式。

例4.3 如图4.3，求a~k各格是雷的概率。

![][pic4.3]

可以看到，这次的局面给出了剩余雷数，因为它很重要。

另外，还要定义三个符号：将不属于任何1阶闲者集的格子构成的闲者集记为Sage。记格子x是雷的概率为p(x)。如果闲者集A的每个格子是雷的概率都等于p，记p(A)=p。

因为一个局面的剩余雷数是一定的，所以类似于袋中取球问题。某格a是雷的概率，就等于“a是雷时的合法布局数”除以“合法布局数”。

本例中有两个闲者集，A={a,b,e,h,i}，Sage={c,d,f,g,j,k}。易知(A)=4，(Sage)=1。则合法布局数=C(5,4)C(6,1)；对于任何x∈A，x是雷时的布局数=C(4,3)C(6,1)，p(A)=C(4,3)C(6,1)/C(5,4)C(6,1)=4/5；类似，对于p(Sage)=1/6。

到这里，结果还是比较明显的。但是算出来之后，既不能open，也不能flag，似乎对游戏进程没什么帮助。然而我们在4.3基础上再打开一块之后：

例4.4 如图4.4，求标着字母的各格是雷的概率。

![][pic4.4]

记数字4那格的闲者集为A，数字3那格的闲者集为B。本例中，Sage=Φ。

要求合法局面数，就需要知道剩余的5个雷在这几个不相交的闲者集{A\B，AB，B\A}中是如何分配的。

易知，雷在{A\B，AB，B\A}中的分配只能是{2,2,1}。

于是，p(A\B)=1，p(AB)=2/3，p(B\A)=1/5。所以，可以flag A\B。

这个故事告诉我们，算概率可以推动游戏进程。而且，这个局面并不能从确定型分析法获得任何指导，因为确定型分析法没有考虑剩余雷数。

如果把确定型和概率型分析法结合起来呢？譬如在MD(1)分析法中添加这条规则：

+ 当|x|>(x)>0，p(x)=|x|/(x)。

然后，当任何MD分析法无能为力，就从p(x)最小的闲者集x中选一块open。对于MD(1)分析法前两条确定型的规则，也可以转化为p=1和p=0的表示。这就是概率型分析法的思路。

至于选x中的哪一块，也是有说法的。应该选“如果打开是数字，能提供最多信息”的那一块。果壳网有一篇研究“开雷提供信息量”的文章《扫雷第一步，先戳哪里最高效？》，见于goo.gl/Pdm6I 。

把雷局放在水平面上，用高度表示是雷的概率，我脑补一下把概率型算法过程可视化的场景：概率的水面波澜不惊，突然上帝之手open一块水面，仿佛砸进一块石板，概率被砸到0，凹陷为谷。周围的水，要么被带入谷底，万劫不复；要么掀起巨浪，若是浪头触到概率1的天际，则静止不落，崛起为峰。完全自动的波澜起伏势不可挡，硬是把全部水面分成了高度为1的峰顶和高度为0的谷底；沟壑纵横齐声宣布，“我们胜利了！”。

##5. NF，FL，3BV，ZINI，纪录，以及saolei.net和minesweeper.info

+ NF指只open，不flag的玩法。当然也不chrod。FL指open、flag、chord都允许的玩法。
+ 一个雷局的3BV值，指只用open操作完成雷局时，所需要的最少操作次数。3BV是衡量一个雷局难度的指标之一。
+ 一个雷局的ZINI值，指open、flag、chord操作并用时，完成雷局的最少操作次数。ZINI也用于衡量雷局难度。不同于3BV值的易于计算，ZINI值的算法仍是有待研究的问题。
+ 目前的中国纪录，解开高级（16*30格，99雷）的最短时间是38.82秒，由张砷镓在2008年1月26日创造。张砷镓同时也是扫雷网创始人，中国魔方三阶速拧第一人 。解开高级的世界纪录是31.13秒，由波兰的Kamil Muranski在2010年7月3日创造。
+ 中国扫雷排行见于扫雷网saolei.net，世界排行见于minesweeper.info。需要注意的是，在这两个站点提交纪录的载体，必须是指定的扫雷软件以内置功能录制的录像。

~~
##6. 未来
我（也许会变成我们）的关于扫雷的研究和开发成果，会不断发布在github.com/SnowOnion。鉴于杂志从投稿到出街（出宿舍...）有数个月的时间差，在诸位读者看到本文时，我保证上述网址会存在：1) 一个扫雷游戏的实现，以及源码；2) 一个扫雷自动求解器——它能应用于1)和大部分主流扫雷游戏——以及源码；3) 本文的进化版本，填上大部分的坑。
~~

行文匆忙，难免疏漏。请读者不吝Debug，任何相关事宜可在snowonionlee@gmail.com交流。
谨以此文，与诸位扫雷爱好者，或是看完本文成为扫雷爱好者的同学（会有吗？:)）共勉。